#include <iostream>

using namespace std;

class Stack {
private:
	char* arr; //Указатель на массив, где будут храниться элементы стека
	int capacity; //Макс. вместимость стека
	int topIndex; //Индекс верхнего элемента стека, -1 означает, что стек пуст

public:

	//Конструктор: создает стек заданной вместимости 
	Stack(int capacity) {
		this->capacity = capacity;// Сохраняем переданное значение макс вместимости 
		arr = new char[capacity];// Выделяем динамическую память под массив
		topIndex = -1; //Изначально стек пуст, поэтому индекс верхнего элемента -1
	}

	//Деструктор
	~Stack() {
		delete[] arr; //Освобождает динамически выделенную память
	}

	//Метод push: добавляет элемент в стек
	void push(char element) {

		//Проверяем, не переполнен ли стек
		if (topIndex >= capacity - 1) { //Если topIndex больше или равно размеру стека -1 (-1 тк индексация с 0)
			cout << "Ошибка! Стек переполнен!" << endl;//Если переполнен, выводит ошибку
			return;
		}

		topIndex++; //Увеличивает индекс верхенго элемента на 1
		arr[topIndex] = element;//Помещает элемент на вершину стека
	}

	void pop() {
		//Проверяем, не пуст ли стек
		if (topIndex < 0) { //Если topIndex верхнего элемента меньше 0 
			cout << "Ошибка! Стек пуст!" << endl;//Если пуст, выводит ошибку
			return;
		}

		topIndex--; //Уменьшаем индекс верхнего элемента на 1
	}

	// Метод top: смотрим, что находится на вершине стека, не убирая этот элемент
	char top() {
		//Проверяем, не пуст ли стек
		if (topIndex < 0) { //Если topIndex верхнего элемента меньше 0 
			cout << "Ошибка! Стек пуст!" << endl;//Если пуст, выводит ошибку
			return '\0'; //Возвращаем 0 символ, если стек пуст
		}

		return arr[topIndex]; //Возвращает значение верхнего элемента
	}

	// Метод empty : проверяет, пуст ли стек
	bool empty() {
		return (topIndex < 0); // Если индекс верхнего элемента меньше 0, значит, стек пуст, возвращаем true, иначе - false
	}
	// Метод size: возвращает размер стека
	int size() {
		return topIndex + 1;
	}
};

// Функция для проверки правильности скобочного выражения
bool isBalanced(const char* expression) {
	// Определяем длину выражения
	int length = 0;
	while (expression[length] != '\0') { // Пока не встретим символ конца строки 
		length++; //Увеличивает счетчик длины
	}
	
	// Создаем стек, размер которого равен длине выражения
	Stack stack(length);

	// Проходим по каждому символу в выражении
	for (int i = 0; i < length; ++i) {
		char c = expression[i]; // Получаем текущий символ

		// Если символ - открывающая скобка, добавляем ее в стек
		if (c == '(' || c == '[' || c == '{') {
			stack.push(c); // Помещаем открывающую скобку на вершину стека
		}
		// Если символ - закрывающая скобка, проверяем соответствие
		else if (c == ')' || c == ']' || c == '}') {
			// Если стек пуст, значит, закрывающая скобка без открывающей (нет пары)
			if (stack.empty()) {
				return false; // Выражение несбалансировано, возвращаем false
			}
			// Получаем верхний элемент стека (последнюю открывающую скобку)
			char top = stack.top(); // Смотрим, какая открывающая скобка находится на вершине стека
			stack.pop(); // Удаляем верхний элемент (т.к. нашли парную закрывающую скобку)

			// Проверяем соответствие типов скобок (правильно ли закрыта скобка)
			if ((c == ')' && top != '(') || (c == ']' && top != '[') || (c == '}' && top != '{')) {
				return false; // Выражение несбалансировано, возвращаем false
			}
		}
		// Игнорируем все остальные символы (не скобки)
	}

	// После обработки всех символов стек должен быть пуст (все скобки должны быть закрыты)
	return stack.empty(); // Если стек пуст, выражение сбалансировано, возвращаем true, иначе - false
}

int main() {
	// Определяем тестовые выражения (массивы символов, оканчивающиеся нулевым символом '\0')
	const char* expression1 = "2+4-5(87192479_7348){72648]76823[]"; // Несбалансированное выражение
	const char* expression2 = "({[]})"; // Сбалансированное выражение
	const char* expression3 = "(([}{)"; // Несбалансированное выражение

	// Выводим результаты проверки для каждого выражения
	cout << expression1 << " -> " << (isBalanced(expression1) ? "yes" : "no") << endl; // Вывод: no (несбалансировано)
	cout << expression2 << " -> " << (isBalanced(expression2) ? "yes" : "no") << endl; // Вывод: yes (сбалансировано)
	cout << expression3 << " -> " << (isBalanced(expression3) ? "yes" : "no") << endl; // Вывод: no (несбалансировано)

	return 0; // Завершаем программу
}

/*Стек хранит только открывающие скобки.
Закрывающая скобка должна соответствовать верхней открывающей скобке в стеке.
Если соответствие не найдено, выражение считается несбалансированным.*/