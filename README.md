Что такое Стек (Stack)?
Стек (Stack) - это абстрактный тип данных (АТД), представляющий собой коллекцию элементов, организованных по принципу "последним пришел - первым ушел" (LIFO - Last-In, First-Out). Представьте стопку тарелок: последняя добавленная тарелка будет первой, которую вы возьмете.

Иллюстрация stack
Еще один мемный, но понятный пример с Хабр <3
Из чего состоит Стек?
push(element): добавляет элемент в вершину стека. Эта операция также называется “поместить” или “затолкнуть”.
pop(): удаляет элемент с вершины стека и возвращает его значение. Эта операция также называется «извлечь» или «вытолкнуть».
peek(): возвращает значение элемента, находящегося на вершине стека, но не удаляет его.
isEmpty(): проверяет, пуст ли стек.
isFull() (опционально): проверяет, заполнен ли стек (актуально только для реализаций на основе массива фиксированного размера).
size() (опционально): возвращает количество элементов в стеке.

Где используются Стеки?
Стеки находят широкое применение в различных областях программирования:

Управление вызовами функций: когда функция вызывает другую функцию, адрес возврата и локальные переменные вызывающей функции помещаются в стек. Когда вызываемая функция завершается, её данные извлекаются из стека, и выполнение программы возвращается в вызывающую функцию.
Отмена действий (Undo/Redo): в текстовых и графических редакторах стек используется для хранения истории действий пользователя. Операция "Отменить" извлекает последнее действие из стека, а операция "Повторить" возвращает отмененное действие обратно в стек.
Вычисление выражений: стеки применяются для вычисления выражений в обратной польской записи (RPN).
Обход деревьев и графов: стеки могут быть использованы для реализации алгоритмов обхода деревьев и графов.
Проверка баланса скобок: стеки могут использоваться для проверки правильности расстановки скобок в выражениях (например, `(a + b) * (c - d)`).


Преимущества использования Стека:
Простота использования: предоставляет простой и понятный интерфейс для работы со стеком.
Безопасность: инкапсулирует данные и обеспечивает контролируемый доступ к ним.
Гибкость: Может использовать различные базовые контейнеры.
Стандартизация: Является частью стандартной библиотеки C++, что обеспечивает переносимость кода.
Когда использовать Стек:
Когда требуется структура данных LIFO.
Когда необходимо инкапсулировать доступ к данным и предоставить контролируемый интерфейс.
Когда важна простота и удобство использования.
Ограничения:
Не предоставляет доступ к элементам, кроме верхнего. Нельзя получить доступ к элементам по индексу.
Не предоставляет итераторы для обхода элементов. Нельзя перебрать элементы стека без их извлечения.
Операция pop() не возвращает удалённый элемент (в отличие от некоторых других реализаций стека).


Описание проекта
Данный проект представляет собой реализацию структуры данных "стек" (Stack) на языке C++. Стек реализован с использованием массива фиксированного размера, что позволяет хранить элементы одного типа (в данном случае `int`). Реализация демонстрирует основные принципы работы стека: "последний пришел - первый ушел" (LIFO - Last-In, First-Out).



Класс `Stack`

Поля класса:

`int* arr`: Указатель на динамически выделенный массив целых чисел, который используется для хранения элементов стека.
`int top`: Индекс верхнего элемента стека.
`-1` означает, что стек пуст.
Всегда указывает на последний добавленный элемент.
`int capacity`: Максимальная вместимость стека (размер массива `arr`).


Методы класса:

1. `Stack(int capacity)` (Конструктор):

 a. Принимает целое число `capacity`, определяющее максимальную вместимость стека.

b. Инициализирует поле `capacity`.

c. Выделяет память под массив `arr` размером `capacity` с помощью оператора `new`. Важно: Память, выделенная с помощью `new`, должна быть освобождена с помощью `delete[]` в деструкторе.

d. Устанавливает `top` в `-1`, что указывает на то, что стек изначально пуст.



2. `~Stack()` (Деструктор):

a. Освобождает память, выделенную под массив `arr` в конструкторе, с помощью `delete[] arr`. Это предотвращает утечки памяти.



3. `bool isEmpty()`:

 a. Возвращает `true`, если стек пуст (`top == -1`), и `false` в противном случае.



4. `bool isFull()`:

  a. Возвращает `true`, если стек полон (`top == capacity - 1`), и `false` в противном случае.



5. `void push(int element)`:

  a. Проверяет, не полон ли стек с помощью `isFull()`. Если полон, выводит сообщение об ошибке "Stack Overflow!" и завершает выполнение функции.

  b. Увеличивает `top` на 1 (`top++`).

  c. Помещает `element` в массив `arr` по индексу `top` (`arr[top] = element`).



6. `int pop()`:

  a. Проверяет, не пуст ли стек с помощью `isEmpty()`. Если пуст, выводит сообщение об ошибке "Stack Underflow!" и возвращает `-1`.

  b. Сохраняет значение элемента, находящегося на вершине стека, в переменной `element` (`int element = arr[top]`).

  c. Уменьшает `top` на 1 (`top--`).

  d. Возвращает значение `element`.



7. `int peek()`:

  a. Проверяет, не пуст ли стек с помощью `isEmpty()`. Если пуст, выводит сообщение об ошибке "Stack is empty!" и возвращает `-1`.

  b. Возвращает значение элемента, находящегося на вершине стека (`return arr[top]`).



8. `int getSize() const`:

  a. Возвращает количество элементов в стеке (`return top + 1`).



9. `void clear()`:

  a. Устанавливает `top` в `-1`, делая стек пустым. Физически элементы в массиве остаются, но они больше не считаются частью стека.



10. `void printStack()`:

  a. Проверяет, не пуст ли стек с помощью `isEmpty()`. Если пуст, выводит сообщение "Stack is empty.".

  b. Выводит сообщение "Stack contents: ".

  c. Использует цикл `for (int i = top; i >= 0; i--)` для прохода по элементам стека от вершины (`top`) до основания (0).

  d. Внутри цикла выводит значение каждого элемента `arr[i]` с пробелом.

  e. Выводит символ новой строки (`endl`).



Пошаговое объяснение примера:
Stack s(5): Создается объект s класса Stack с максимальной вместимостью 5 элементов.
s.push(10), s.push(20), s.push(30): элементы 10, 20 и 30 добавляются на вершину стека. Теперь стек содержит элементы: [10, 20, 30] (с 30 на вершине).
s.printStack(): Выводит содержимое стека в консоль: «Содержимое стека: 30 20 10».
s.pop(): Удаляет элемент с вершины стека (30). Теперь стек содержит элементы: [10, 20] (с 20 на вершине).
s.printStack(): Выводит содержимое стека в консоль после удаления элемента: «Содержимое стека: 20 10».
return 0: Программа завершается.


Обработка ошибок
Переполнение стека: если попытаться добавить элемент в полный стек (когда isFull() возвращает true), выводится сообщение об ошибке «Переполнение стека!».
Переполнение стека: если попытаться удалить элемент из пустого стека (когда isEmpty() возвращает true), выводится сообщение об ошибке “Переполнение стека!” и функция pop() возвращает -1.


Возможные улучшения
Динамический размер: реализовать стек с динамическим изменением размера, используя, например, std::vector.
Исключения: Использовать исключения для более надежной обработки ошибок.
Шаблоны: Используйте шаблоны (template <typename T>) для создания стека, который может хранить элементы любого типа.
Более информативные сообщения об ошибках: предоставлять более подробную информацию об ошибках (например, номер строки, в которой произошла ошибка).

Источники: 

https://habr.com/ru/articles/341586/
https://skillbox.ru/media/code/prostymi-slovami-chto-takoe-stek-i-kak-on-ustroen/#stk-1
https://tproger.ru/translations/stacks-and-queues-for-beginners
https://chatgptchatapp.com/
